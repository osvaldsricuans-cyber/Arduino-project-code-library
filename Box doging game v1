#include <U8g2lib.h>
#include <SPI.h>
#include <math.h>

// --- Joystick pins ---
#define VRX A0
#define VRY A1
#define SW  A2

// --- Extra buttons ---
#define BTN1 A3  // Collision toggle
#define BTN2 A4  // Pause
#define BTN3 A5  // Reset

U8G2_SH1106_128X64_NONAME_F_4W_HW_SPI U8G2(U8G2_R0, 10, 8, 9);

// --- Player ---
int Px = 64;
int Py = 32;
int aimDX = 0;
int aimDY = -10;
int playerRadius = 5;
int boxPadding = 5;

// --- Enemy ---
struct Enemy {
  float x, y;
  float speed;
  int radius;
};
#define NUM_ENEMIES 5
Enemy enemies[NUM_ENEMIES];

// --- Game state ---
bool collisionsEnabled = true;   // collision toggle
bool collision = false;          // collision flag
unsigned long cooldownStart = 0; // cooldown timer
bool cooldownActive = false;
unsigned long cooldownDuration = 5000; // 5s cooldown
unsigned long disableDuration = 1000;  // collision off duration

bool gameStarted = false;
bool paused = false;
bool gameOver = false;
unsigned long startMillis = 0;
unsigned long survivedMillis = 0;

void setup() {
  Serial.begin(9600);
  U8G2.begin();
  U8G2.setFont(u8g2_font_ncenB08_tr);

  pinMode(SW, INPUT_PULLUP);
  pinMode(BTN1, INPUT_PULLUP);
  pinMode(BTN2, INPUT_PULLUP);
  pinMode(BTN3, INPUT_PULLUP);

  // Initialize enemies
  for(int i=0; i<NUM_ENEMIES; i++){
    enemies[i].x = random(0, 128);
    enemies[i].y = random(0, 64);
    enemies[i].radius = random(3,6);
    enemies[i].speed = random(1,3);
  }
}

void loop() {
  unsigned long t = millis() - startMillis;

  // --- Countdown before game ---
  if(!gameStarted){
    U8G2.clearBuffer();
    if(t < 2000) {
      U8G2.setCursor(10, 32); U8G2.print("Izvairies no kastem");
    } else if(t < 3000) {
      U8G2.setCursor(64, 32); U8G2.print("3");
    } else if(t < 4000) {
      U8G2.setCursor(64, 32); U8G2.print("2");
    } else if(t < 5000) {
      U8G2.setCursor(64, 32); U8G2.print("1");
    } else if(t < 6000) {
      U8G2.setCursor(50, 32); U8G2.print("Aiziet");
    } else {
      gameStarted = true;
      collisionsEnabled = true;
      startMillis = millis(); // start survived timer
    }
    U8G2.sendBuffer();
    return;
  }

  // --- Pause toggle ---
  static bool lastPauseState = HIGH;
  bool pauseBtn = digitalRead(BTN2);
  if(pauseBtn == LOW && lastPauseState == HIGH){
    paused = !paused;
  }
  lastPauseState = pauseBtn;

  // --- Reset ---
  static bool lastResetState = HIGH;
  bool resetBtn = digitalRead(BTN3);
  if(resetBtn == LOW && lastResetState == HIGH){
    resetGame();
  }
  lastResetState = resetBtn;

  if(paused || gameOver){
    U8G2.clearBuffer();
    if(paused){
      U8G2.setCursor(50,32); U8G2.print("PAUSE");
    } else if(gameOver){
      U8G2.setFont(u8g2_font_ncenB14_tr);
      U8G2.setCursor(20,32); U8G2.print("Tu zaudeji");
      U8G2.setCursor(3,50);
      U8G2.print("Survived: ");
      U8G2.print(survivedMillis / 1000);
      U8G2.print("s");
      U8G2.setFont(u8g2_font_ncenB08_tr);
    }
    if(cooldownActive){
      unsigned long timeLeft = (cooldownDuration - (millis() - cooldownStart))/1000;
      U8G2.setCursor(80,10); U8G2.print("CD:"); U8G2.print(timeLeft+1);
    }
    U8G2.sendBuffer();
    delay(20);
    return;
  }

  // --- Update survived time ---
  survivedMillis = millis() - startMillis;

  // --- Read joystick ---
  int x = analogRead(VRX);
  int y = analogRead(VRY);

  // --- Movement & aiming ---
  if (x < 400) { Px -= 1; aimDX=-10; aimDY=0; }
  if (x > 600) { Px += 1; aimDX=10; aimDY=0; }
  if (y < 400) { Py -= 1; aimDX=0; aimDY=-10; }
  if (y > 600) { Py += 1; aimDX=0; aimDY=10; }

  // Clamp player inside screen
  Px = constrain(Px, 10, 117);
  Py = constrain(Py, 10, 53);

  // --- Update enemies ---
  for(int i=0;i<NUM_ENEMIES;i++){
    enemies[i].x += enemies[i].speed; // move right
    if(enemies[i].x - enemies[i].radius > 127){
      enemies[i].x = -enemies[i].radius;
      enemies[i].y = random(5, 58);
    }
  }

  // --- Collision toggle button ---
  if(digitalRead(BTN1) == LOW && !cooldownActive){
    collisionsEnabled = false;        // disable collisions
    cooldownActive = true;
    cooldownStart = millis();         // start cooldown timer
  }

  // --- Manage collision disable duration ---
  if(!collisionsEnabled && (millis() - cooldownStart >= disableDuration)){
    collisionsEnabled = true;         // re-enable collisions after 1 sec
  }

  // --- Manage cooldown ---
  if(cooldownActive && (millis() - cooldownStart >= cooldownDuration)){
    cooldownActive = false;          // button can be pressed again
  }

  // --- Check collisions ---
  collision = false;
  if(collisionsEnabled){
    for(int i=0;i<NUM_ENEMIES;i++){
      float ex = enemies[i].x - enemies[i].radius;
      float ey = enemies[i].y - enemies[i].radius;
      float ew = enemies[i].radius * 2;
      float eh = enemies[i].radius * 2;

      float closestX = constrain(Px, ex, ex + ew);
      float closestY = constrain(Py, ey, ey + eh);

      float dx = Px - closestX;
      float dy = Py - closestY;

      if(dx*dx + dy*dy < playerRadius*playerRadius){
        collision = true;
        gameOver = true; // stop the game
      }
    }
  }

  // --- Draw everything ---
  U8G2.clearBuffer();

  // Border
  U8G2.drawLine(0,0,0,63);
  U8G2.drawLine(0,0,127,0);
  U8G2.drawLine(127,63,0,63);
  U8G2.drawLine(127,63,127,0);

  // Enemies
  for(int i=0;i<NUM_ENEMIES;i++){
    U8G2.drawBox(enemies[i].x - enemies[i].radius, enemies[i].y - enemies[i].radius,
                 enemies[i].radius*2, enemies[i].radius*2);
  }

  // Player
  int lineX = constrain(Px + aimDX, 0, 127);
  int lineY = constrain(Py + aimDY, 0, 63);
  U8G2.drawCircle(Px, Py, playerRadius);
  U8G2.drawLine(Px, Py, lineX, lineY);

  // Box around player if collisions disabled
  if(!collisionsEnabled){
    int boxX = Px - playerRadius - boxPadding;
    int boxY = Py - playerRadius - boxPadding;
    int boxSize = (playerRadius + boxPadding)*2;
    U8G2.drawFrame(boxX, boxY, boxSize, boxSize);
  }

  // Time survived at bottom-left
  U8G2.setCursor(0,63);
  U8G2.print("Time: ");
  U8G2.print(survivedMillis / 1000);
  U8G2.print("s");

  // Cooldown timer top-right
  if(cooldownActive){
    unsigned long timeLeft = (cooldownDuration - (millis() - cooldownStart))/1000;
    U8G2.setCursor(80,10);
    U8G2.print("CD:"); U8G2.print(timeLeft+1);
  }

  U8G2.sendBuffer();
  delay(20);
}

void resetGame(){
  Px = 64; Py = 32;
  collisionsEnabled = true;
  cooldownActive = false;
  gameOver = false;
  survivedMillis = 0;
  startMillis = millis();
  // reset enemies
  for(int i=0;i<NUM_ENEMIES;i++){
    enemies[i].x = random(0, 128);
    enemies[i].y = random(0, 64);
    enemies[i].radius = random(3,6);
    enemies[i].speed = random(1,3);
  }
}
